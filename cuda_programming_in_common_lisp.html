<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="mahmood" />
<meta name="generator" content="Org Mode" />
<title>cuda programming in common lisp</title><!-- lambda icon, frail attempt -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%22100%22 color=%22red%22>λ</text></svg>">
<!-- not-so-awesome awesome font -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

<link rel="stylesheet" href="/main.css">
</head>
<body>
<div id="preamble" class="status">
<div class="navbar">
  <a href='/'>home</a>
  <a href='/blog.html'>blog</a>
  <a href='/archive.html'>archive</a>
  <a href='/about.html'>about</a>
</div><h1 class="main-title">cuda programming in common lisp</h1>
</div>
<div id="content" class="content">
<p>
using <code>cl-cuda</code>
load it using quicklisp:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(ql:quickload <span style="font-weight: bold;">:cl-cuda</span>)
</pre>
</div>
<div id="outline-container-org90a2be2" class="outline-2">
<h2 id="org90a2be2">arch linux setup</h2>
<div class="outline-text-2" id="text-org90a2be2">
<p>
i had to install <code>cuda</code> for the <code>nvcc</code> compiler and more, and <code>nvidia</code> for the gpu driver
at first you may have to use <code>/opt/cuda/bin/nvcc</code> until you reboot or extend your $PATH
to check which nvidia driver is in use run:
</p>
<div class="org-src-container">
<pre class="src src-sh">lspci -k | grep -A 2 -E <span style="font-style: italic;">"(VGA|3D)"</span>
</pre>
</div>

<p>
if you have installed the <code>nvidia</code> package and your os still uses <code>nouveau</code> you need to reboot
if it still doesnt use <code>nvidia</code> you need to update your while system with <code>pacman -Syyu</code> (you've been doing partial upgrades)
</p>
</div>
</div>
<div id="outline-container-orgc8bb7c0" class="outline-2">
<h2 id="orgc8bb7c0">essential concepts</h2>
<div class="outline-text-2" id="text-orgc8bb7c0">
</div>
<div id="outline-container-orgd5ca331" class="outline-3">
<h3 id="orgd5ca331">threads</h3>
<div class="outline-text-3" id="text-orgd5ca331">
<p>
mostly from <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model</a>
i also read the examples from the cl-cuda's source code
<b>kernels</b> are just functions that are run by different cuda threads in a <b>thread block</b>, a thread block is a group of threads each given an index, thread blocks can be nested up to 3 times, an index is a 3d vector with each value corresponding to the index in one of the dimensions x,y,z, there is a limit to the number of threads per block, which on current GPUs is 1024. the index of a thread is stored in the special variable <code>threadIdx</code>, the index of a block is stored in the special variable <code>blockIdx</code>, the dimensions of a block can be given by <code>blockDim</code>, all of these variables are 3d vectors and have <code>x,y,z</code> members.
</p>

<p>
a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.
</p>

<p>
blocks are organized into a one-dimensional, two-dimensional, or three-dimensional <b>grid of thread blocks</b>. the number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system.
</p>

<p>
a thread block size of 16x16 (256 threads) is a common choice
thread blocks are required to execute independently: it must be possible to execute them in any order, in parallel or in series. this independence requirement allows thread blocks to be scheduled in any order across any number of cores, enabling programmers to write code that scales with the number of cores.
</p>

<p>
threads within a block can cooperate by sharing data through some <b>shared memory</b> and by synchronizing their execution to coordinate memory accesses. more precisely, one can specify synchronization points in the kernel by calling the <code>__syncthreads()</code> intrinsic function; <code>__syncthreads()</code> acts as a barrier at which all threads in the block must wait before any is allowed to proceed. in addition to <code>__syncthreads()</code>, the cooperative groups api provides a rich set of thread-synchronization primitives.
</p>

<p>
for efficient cooperation, the shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and <code>__syncthreads()</code> is expected to be lightweight.
</p>
</div>
</div>
<div id="outline-container-orgacce46a" class="outline-3">
<h3 id="orgacce46a">memory</h3>
<div class="outline-text-3" id="text-orgacce46a">
<p>
CUDA threads may access data from multiple memory spaces during their execution. each thread has private <b>local memory</b>. each thread block has <b>shared memory</b> visible to all threads of the block and with the same lifetime as the block. thread blocks in a thread block cluster can perform read, write, and atomics operations on each other’s shared memory. all threads have access to the same <b>global memory</b>.
</p>

<p>
there are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces. the global, constant, and texture memory spaces are optimized for different memory usages. texture memory also offers different addressing modes, as well as data filtering, for some specific data formats.
</p>

<p>
the global, constant, and texture memory spaces are persistent across kernel launches by the same application.
</p>

<p>
<b>unified memory</b> provides <b>managed memory</b> to bridge the host and <b>device memory</b> spaces. managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. this capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device.
</p>

<p>
the CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as host memory and device memory, respectively. therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime. this includes device memory allocation and deallocation as well as data transfer between host and device memory.
</p>

<p>
unified memory provides managed memory to bridge the host and device memory spaces. managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. this capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device.
</p>
</div>
</div>
<div id="outline-container-org241007e" class="outline-3">
<h3 id="org241007e">device memory</h3>
<div class="outline-text-3" id="text-org241007e">
<p>
the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.
</p>

<p>
device memory can be allocated either as linear memory or as <b>CUDA arrays</b>.
</p>

<p>
CUDA arrays are opaque memory layouts optimized for texture fetching.
</p>

<p>
<b>linear memory</b> is allocated in a single unified address space, which means that separately allocated entities can reference one another via pointers, for example, in a binary tree or linked list. the size of the address space depends on the host system (CPU) and the compute capability of the used GPU:
</p>
</div>
</div>
</div>
<div id="outline-container-org8ca2a3a" class="outline-2">
<h2 id="org8ca2a3a">code</h2>
<div class="outline-text-2" id="text-org8ca2a3a">
<p>
see <a href="/connect_to_remote_common_lisp_repl_with_sly_slime.html">connect to remote common lisp repl with sly/slime</a> for connecting to a remote common lisp repl with emacs
</p>
<div class="math-block note" data-before="note" data-after="" id="org8ac6a66">
<p>
notice that when working cl-cuda the data that we're passing to the gpu is gonna be duplicated (because its a binding from cl to C and uses whats called foreign memory), i never considered how bad that is, atleast in this case, as mostly when doing gpu calculations we're ofcourse passing lots of data and then copying it back, and the maximum amount of memory that i can use is already cut in half, if i have 16gb of memory i already know i cant use more than 8gb of that, thats pretty horrible (assuming i have a gpu with ~16gb memory), i can have my way around this, e.g. free memory from sbcl as it gets copied to C, but that'd be much more complexity than i wanna have to deal with
</p>

</div>
</div>
<div id="outline-container-org46d700d" class="outline-3">
<h3 id="org46d700d">cuda vector addition</h3>
<div class="outline-text-3" id="text-org46d700d">
<p>
we start with the vectorAdd example, a simple example in C, stolen from <a href="https://github.com/NVIDIA/cuda-samples/blob/master/Samples/0_Introduction/vectorAdd/vectorAdd.cu">https://github.com/NVIDIA/cuda-samples/blob/master/Samples/0_Introduction/vectorAdd/vectorAdd.cu</a> and modified to reduce boilerplate code.
</p>

<p>
the syntax for calling a kernel in c++ is <code>vector&lt;&lt;&lt; blocks per grid, threads per block &gt;&gt;&gt;(arg1,arg2,...)</code>
consider the following program which does vector addition
place this code in a file with a <code>.cu</code> extension (only .cu works)
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;</span><span style="font-style: italic;">stdio.h</span><span style="font-style: italic;">&gt;</span>

__global__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">vector_add</span>(<span style="font-weight: bold; text-decoration: underline;">float</span> *<span style="font-weight: bold; font-style: italic;">c</span>, <span style="font-weight: bold; text-decoration: underline;">float</span> *<span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; text-decoration: underline;">float</span> *<span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
    c[i] = a[i] + b[i];
  }
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span> = 1000; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">length of vectors</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span> = N * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">size of a vector in memory</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocate vectors in host memory</span>
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">host_a</span> = (<span style="font-weight: bold; text-decoration: underline;">float</span>*)malloc(size);
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">host_b</span> = (<span style="font-weight: bold; text-decoration: underline;">float</span>*)malloc(size);
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">host_c</span> = (<span style="font-weight: bold; text-decoration: underline;">float</span>*)malloc(size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">output vector a+b=c</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">initialize host input vectors</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; N; i++) {
    host_a[i] = 1.0f;
    host_b[i] = 2.0f;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocate (global) linear memory for vectors on the device (gpu)</span>
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">device_a</span>;
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">device_b</span>;
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">device_c</span>;
  cudaMalloc(&amp;device_a, size);
  cudaMalloc(&amp;device_b, size);
  cudaMalloc(&amp;device_c, size);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy vectors from host memory to device memory</span>
  cudaMemcpy(device_a, host_a, size, cudaMemcpyHostToDevice);
  cudaMemcpy(device_b, host_b, size, cudaMemcpyHostToDevice);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">invoke kernel</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">threads_per_block</span> = 256;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">blocks_per_grid</span> =
    (N + threads_per_block - 1) / threads_per_block;
  vector_add&lt;&lt;&lt;blocks_per_grid, threads_per_block&gt;&gt;&gt;(device_c, device_b, device_a, N);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy result from device memory to host memory</span>
  cudaMemcpy(host_c, device_c, size, cudaMemcpyDeviceToHost);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free device memory</span>
  cudaFree(device_a);
  cudaFree(device_b);
  cudaFree(device_c);

  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; N; ++i) {
    printf(<span style="font-style: italic;">"%d: %f\n"</span>, i, host_c[i]);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free host memory</span>
  free(host_a);
  free(host_b);
  free(host_c);
}
</pre>
</div>
<p>
compile with <code>nvcc &lt;name&gt;.cu -o vector_add</code> and run with <code>./vector_add</code>
similar same code but in cl:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">random-init</span> (data n)
  (<span style="font-weight: bold;">dotimes</span> (i n)
    (setf (cl-cuda:memory-block-aref data i) (random 1.0))))

(cl-cuda:defkernel vec-add-kernel (cl-cuda:void ((a cl-cuda:float*) (b cl-cuda:float*) (c cl-cuda:float*) (n cl-cuda:int)))
  (<span style="font-weight: bold;">let</span> ((i (+ (* cl-cuda:block-dim-x cl-cuda:block-idx-x) cl-cuda:thread-idx-x)))
    (<span style="font-weight: bold;">if</span> (&lt; i n)
        (set (aref c i)
             (+ (aref a i) (aref b i))))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">main</span> ()
  (<span style="font-weight: bold;">let*</span> ((dev-id 0)
         (n 1024)
         (threads-per-block 256)
         (blocks-per-grid (/ n threads-per-block)))
    (cl-cuda:with-cuda (dev-id)
      (cl-cuda:with-memory-blocks ((a 'float n) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">allocate (global) linear memory on both host+device</span>
                                   (b 'float n)
                                   (c 'float n))
        (random-init a n)
        (random-init b n)
        (cl-cuda:sync-memory-block a <span style="font-weight: bold;">:host-to-device</span>)
        (cl-cuda:sync-memory-block b <span style="font-weight: bold;">:host-to-device</span>)
        (vec-add-kernel a b c n
                        <span style="font-weight: bold;">:grid-dim</span> (list blocks-per-grid 1 1)
                        <span style="font-weight: bold;">:block-dim</span> (list threads-per-block 1 1))
        (cl-cuda:sync-memory-block c <span style="font-weight: bold;">:device-to-host</span>)
        (<span style="font-weight: bold;">loop</span> for i from 0 below 1024
              do (print (cl-cuda:memory-block-aref c i)))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org7d372db" class="outline-3">
<h3 id="org7d372db">cuda matrix multiplication</h3>
<div class="outline-text-3" id="text-org7d372db">
<p>
mostly taken from <a href="https://docs.nvidia.com/deeplearning/performance/dl-performance-matrix-multiplication/index.html">https://docs.nvidia.com/deeplearning/performance/dl-performance-matrix-multiplication/index.html</a> and <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model</a>
before implementing matrix multiplication for the <b>gpu</b> we need to consider some things
the product of two matrices <img src="ltx/7bfaa93f10a.svg" alt="\(A_{M \times K},B_{K \times N}\)" style="height: 1.1568em; vertical-align: -0.3467em; display: inline-block" class="org-latex org-latex-inline" /> results in a matrix <img src="ltx/12cd4179641.svg" alt="\(C_{M \times N}\)" style="height: 1.1568em; vertical-align: -0.3467em; display: inline-block" class="org-latex org-latex-inline" /> which contains <img src="ltx/aa99bb3e3b6.svg" alt="\(M \cdot N\)" style="height: 0.8593em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> values, each of which is a dot product of K-element vectors. thus a total of <img src="ltx/0a4381989ac.svg" alt="\(M \cdot N \cdot K\)" style="height: 0.8593em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> fused multiply-adds are needed to compute the product. each FMA is 2 operations, a (scalar) multiplication and an addition, so a total of <img src="ltx/6443b310d51.svg" alt="\(2 \cdot M \cdot N \cdot K\)" style="height: 0.9221em; vertical-align: -0.1120em; display: inline-block" class="org-latex org-latex-inline" /> flops are required, if we were to consider gemm, the parameters <img src="ltx/3c7d77d7b98.svg" alt="\(\alpha,\beta\)" style="height: 0.9263em; vertical-align: -0.2773em; display: inline-block" class="org-latex org-latex-inline" /> would also play a role in the number of flops required, but the effect these scalars have can be negligable for sufficiently large matrices.
</p>

<p>
in the example of vector addition, we used <b>global memory</b> (using <code>cudaMalloc</code> in C and <code>with-memory-block</code> in CL), which is (very) slow compared to <b>shared memory</b> which is allocated per <b>thread block</b>. we also did one <b>floating point operation</b> per memory access, so with as many flops as we have you can already see how slow we are going.
</p>

<p>
to speed this up we're gonna use shared memory so that threads in a thread block can collaborate in computing a submatrix of the output matrix and to reduce calls to global memory
first, an implementation without shared memory:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;</span><span style="font-style: italic;">stdio.h</span><span style="font-style: italic;">&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;</span><span style="font-style: italic;">stdlib.h</span><span style="font-style: italic;">&gt;</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrices are stored in row-major order:</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">M(row, col) = *(M.elements + row * M.width + col)</span>
<span style="font-weight: bold;">typedef</span> <span style="font-weight: bold;">struct</span> {
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">width</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span>;
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">elements</span>;
} <span style="font-weight: bold; text-decoration: underline;">Matrix</span>;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread block size</span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">BLOCK_SIZE</span> 16

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">forward declaration of the matrix multiplication kernel</span>
__global__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMulKernel</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">Matrix</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">Matrix</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix multiplication - host code</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix dimensions are assumed to be multiples of BLOCK_SIZE</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMul</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">B</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">C</span>)
{
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">load A and B to device memory</span>
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_A</span>;
  d_A.width = A.width; d_A.height = A.height;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span> = A.width * A.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_A.elements, size);
  cudaMemcpy(d_A.elements, A.elements, size,
             cudaMemcpyHostToDevice);
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_B</span>;
  d_B.width = B.width; d_B.height = B.height;
  size = B.width * B.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_B.elements, size);
  cudaMemcpy(d_B.elements, B.elements, size,
             cudaMemcpyHostToDevice);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocate C in device memory</span>
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_C</span>;
  d_C.width = C.width; d_C.height = C.height;
  size = C.width * C.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_C.elements, size);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">invoke kernel</span>
  <span style="font-weight: bold; text-decoration: underline;">dim3</span> <span style="font-weight: bold;">dimBlock</span>(BLOCK_SIZE, BLOCK_SIZE);
  <span style="font-weight: bold; text-decoration: underline;">dim3</span> <span style="font-weight: bold;">dimGrid</span>(B.width / dimBlock.x, A.height / dimBlock.y);
  MatMulKernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(d_A, d_B, d_C);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">read C from device memory</span>
  cudaMemcpy(C.elements, d_C.elements, size,
             cudaMemcpyDeviceToHost);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free device memory</span>
  cudaFree(d_A.elements);
  cudaFree(d_B.elements);
  cudaFree(d_C.elements);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix multiplication kernel called by MatMul()</span>
__global__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMulKernel</span>(<span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">B</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">C</span>)
{
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each thread computes one element of C</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by accumulating results into Cvalue</span>
  <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">Cvalue</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">row</span> = blockIdx.y * blockDim.y + threadIdx.y;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">col</span> = blockIdx.x * blockDim.x + threadIdx.x;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">e</span> = 0; e &lt; A.width; ++e)
    Cvalue += A.elements[row * A.width + e]
      * B.elements[e * B.width + col];
  C.elements[row * C.width + col] = Cvalue;
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">a</span>,<span style="font-weight: bold; font-style: italic;">b</span>,<span style="font-weight: bold; font-style: italic;">c</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">width*height should be a multiple of 16</span>
  <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">elements</span>[16*16];
  c.width = c.height = a.width = a.height = b.width = b.height = 16;
  a.elements = b.elements = elements;
  c.elements = (<span style="font-weight: bold; text-decoration: underline;">float</span>*)malloc(<span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>)*c.width*c.height);
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; c.width * c.height; ++i) {
    a.elements[i] = b.elements[i] = c.elements[i] = i;
  }
  MatMul(a,b,c);
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; c.width * c.height; ++i) {
    printf(<span style="font-style: italic;">"%f\n"</span>, c.elements[i]);
  }
}
</pre>
</div>
<p>
to divide the work with shared memory we load submatrices into each thread block so that threads of each block can operate on the respective submatrix
<img src="/matrix-multiplication-with-shared-memory.png" />
the threads cooperate in loading from memory the values of the input matrices to minimize access to global memory, different thread blocks load different portions of the input matrices, the portions they load are exactly the part of the matrices needed to find the values of the submatrix of C they operate on
the best way to understand this is to read the code
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrices are stored in row-major order:</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">M(row, col) = *(M.elements + row * M.stride + col)</span>
<span style="font-weight: bold;">typedef</span> <span style="font-weight: bold;">struct</span> {
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">width</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">stride</span>;
  <span style="font-weight: bold; text-decoration: underline;">float</span>* <span style="font-weight: bold; font-style: italic;">elements</span>;
} <span style="font-weight: bold; text-decoration: underline;">Matrix</span>;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">get a matrix element</span>
__device__ <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold;">GetElement</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">row</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">col</span>) {
  <span style="font-weight: bold;">return</span> A.elements[row * A.stride + col];
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">set a matrix element</span>
__device__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetElement</span>(<span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">row</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">col</span>, <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">value</span>) {
  A.elements[row * A.stride + col] = value;
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">get the BLOCK_SIZExBLOCK_SIZE sub-matrix Asub of A that is</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">located col sub-matrices to the right and row sub-matrices down</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">from the upper-left corner of A</span>
__device__ <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold;">GetSubMatrix</span>(<span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">row</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">col</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">Asub</span>;
  Asub.width    = BLOCK_SIZE;
  Asub.height   = BLOCK_SIZE;
  Asub.stride   = A.stride;
  Asub.elements = &amp;A.elements[A.stride * BLOCK_SIZE * row
                              + BLOCK_SIZE * col];
  <span style="font-weight: bold;">return</span> Asub;
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread block size</span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">BLOCK_SIZE</span> 16

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">forward declaration of the matrix multiplication kernel</span>
__global__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMulKernel</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">Matrix</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">Matrix</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix multiplication - host code</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix dimensions are assumed to be multiples of BLOCK_SIZE</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMul</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">B</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">C</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">load A and B to device memory</span>
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_A</span>;
  d_A.width = d_A.stride = A.width; d_A.height = A.height;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span> = A.width * A.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_A.elements, size);
  cudaMemcpy(d_A.elements, A.elements, size,
             cudaMemcpyHostToDevice);
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_B</span>;
  d_B.width = d_B.stride = B.width; d_B.height = B.height;
  size = B.width * B.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_B.elements, size);
  cudaMemcpy(d_B.elements, B.elements, size,
             cudaMemcpyHostToDevice);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocate C in device memory</span>
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">d_C</span>;
  d_C.width = d_C.stride = C.width; d_C.height = C.height;
  size = C.width * C.height * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">float</span>);
  cudaMalloc(&amp;d_C.elements, size);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">invoke kernel</span>
  <span style="font-weight: bold; text-decoration: underline;">dim3</span> <span style="font-weight: bold;">dimBlock</span>(BLOCK_SIZE, BLOCK_SIZE);
  <span style="font-weight: bold; text-decoration: underline;">dim3</span> <span style="font-weight: bold;">dimGrid</span>(B.width / dimBlock.x, A.height / dimBlock.y);
  MatMulKernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(d_A, d_B, d_C);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">read C from device memory</span>
  cudaMemcpy(C.elements, d_C.elements, size,
             cudaMemcpyDeviceToHost);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free device memory</span>
  cudaFree(d_A.elements);
  cudaFree(d_B.elements);
  cudaFree(d_C.elements);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">matrix multiplication kernel called by MatMul()</span>
__global__ <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MatMulKernel</span>(<span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">A</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">B</span>, <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">C</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block row and column</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">blockRow</span> = blockIdx.y;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">blockCol</span> = blockIdx.x;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each thread block computes one sub-matrix Csub of C</span>
  <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">Csub</span> = GetSubMatrix(C, blockRow, blockCol);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each thread computes one element of Csub</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by accumulating results into Cvalue</span>
  <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">Cvalue</span> = 0;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread row and column within Csub</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">row</span> = threadIdx.y;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">col</span> = threadIdx.x;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">loop over all the sub-matrices of A and B that are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">required to compute Csub</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">multiply each pair of sub-matrices together</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and accumulate the results</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">m</span> = 0; m &lt; (A.width / BLOCK_SIZE); ++m) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">get sub-matrix Asub of A</span>
    <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">Asub</span> = GetSubMatrix(A, blockRow, m);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">get sub-matrix Bsub of B</span>
    <span style="font-weight: bold; text-decoration: underline;">Matrix</span> <span style="font-weight: bold; font-style: italic;">Bsub</span> = GetSubMatrix(B, m, blockCol);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shared memory (static variables) used to store Asub and Bsub respectively</span>
    __shared__ <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">As</span>[BLOCK_SIZE][BLOCK_SIZE];
    __shared__ <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">Bs</span>[BLOCK_SIZE][BLOCK_SIZE];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">load Asub and Bsub from device memory to shared memory</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each thread loads one element of each sub-matrix</span>
    As[row][col] = GetElement(Asub, row, col);
    Bs[row][col] = GetElement(Bsub, row, col);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">synchronize to make sure the sub-matrices are loaded</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">before starting the computation</span>
    __syncthreads();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">multiply Asub and Bsub together</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">e</span> = 0; e &lt; BLOCK_SIZE; ++e)
      Cvalue += As[row][e] * Bs[e][col];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">synchronize to make sure that the preceding</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">computation is done before loading two new</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sub-matrices of A and B in the next iteration</span>
    __syncthreads();
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">write Csub to device memory</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each thread writes one element</span>
  SetElement(Csub, row, col, Cvalue);
}
</pre>
</div>
<p>
some points to consider before implementating in lisp:
</p>
<ol class="org-ol">
<li>we cant pass structs like in C, unfortunately, we can only allocate linear memory of basic types</li>
<li>for matrices on cpu, i used cl's arrays, for matrices on gpu, im gonna use just C pointers, like in the C example</li>
<li>common lisp implementation will be more complete (i cba doing the same for C), e.g. no assumptions on matrix sizes</li>
<li>loops in kernels can only be done using the <code>do</code> statement</li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">random-init</span> (data n)
  (<span style="font-weight: bold;">dotimes</span> (i n)
    (setf (cl-cuda:memory-block-aref data i) (random 1.0))))

(cl-cuda:defkernel matrix-mul-kernel (cl-cuda:void ((arr1      cl-cuda:float*)
                                                    (arr2      cl-cuda:float*)
                                                    (out       cl-cuda:float*)
                                                    (arr1-rows cl-cuda:int)
                                                    (arr2-cols cl-cuda:int)
                                                    (arr2-rows cl-cuda:int)))
  (<span style="font-weight: bold;">let*</span> ((block-row cl-cuda:block-idx-y) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">location of current thread block in the grid</span>
         (block-col cl-cuda:block-idx-x)
         (row cl-cuda:thread-idx-y) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">cell this thread is responsible for in output matrix</span>
         (col cl-cuda:thread-idx-x)
         (c-value 10.0)
         (arr1-cols arr2-rows)
         (block-size cl-cuda:block-dim-x) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">16 unless modified</span>
         (out-size arr1-rows))
    <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">start iterating through input submatrices</span>
    <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">(set c-value (float arr1-cols))</span>
    (<span style="font-weight: bold;">do</span> ((i 0 (+ i 1)))
        ((&gt;= i (/ arr1-cols block-size)))
      (cl-cuda:with-shared-memory ((arr1-sub float 16 16)
                                   (arr2-sub float 16 16))
        (set (aref arr1-sub row col) (aref arr1 (+ (* block-row block-size)
                                                   (* row block-size)
                                                   (* i block-size)
                                                   col)))
        (set (aref arr2-sub row col) (aref arr2 (+ (* i block-size)
                                                   (* row block-size)
                                                   (* block-col block-size)
                                                   col)))
        (cl-cuda:syncthreads) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">synchronize to make sure submatrices are loaded</span>
        (<span style="font-weight: bold;">do</span> ((j 0 (+ j 1)))
            ((&gt;= j block-size))
          (set c-value (+ c-value (* (aref arr1-sub row j) (aref arr2-sub j col)))))
        <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">synchronize to make sure that the preceding</span>
        <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">computation is done before loading two new</span>
        <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">sub-matrices of A and B in the next iteration</span>
        (cl-cuda:syncthreads)))
    (set (aref out (+ (* block-row block-size)
                      (* block-col block-size)
                      (* row block-size)
                      col)) <span style="font-weight: bold;">c-value</span><span style="font-weight: bold;">)</span><span style="font-weight: bold;">)</span><span style="font-weight: bold;">)</span>

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">cuda-matrix-mul</span> (arr1 arr2)
  (<span style="font-weight: bold;">let*</span> ((out-size (* (array-rows arr1) (array-cols arr2)))
         (dev-id 0)
         (block-size 16) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">actual size is squared, this is more of a "length"</span>
         (threads-per-block (expt block-size 2))
         (blocks-per-grid (/ out-size threads-per-block)))
    (cl-cuda:with-cuda (dev-id)
      (cl-cuda:with-memory-blocks ((c-arr1 'float (array-size arr1))
                                   (c-arr2 'float (array-size arr2))
                                   (c-out 'float out-size))
        (random-init c-arr1 (array-size arr1))
        (random-init c-arr2 (array-size arr2))
        (cl-cuda:sync-memory-block c-arr1 <span style="font-weight: bold;">:host-to-device</span>)
        (cl-cuda:sync-memory-block c-arr2 <span style="font-weight: bold;">:host-to-device</span>)
        (matrix-mul-kernel
         c-arr1 c-arr2 c-out
         (array-rows arr1) (array-cols arr2) (array-rows arr2)
         <span style="font-weight: bold;">:grid-dim</span> (list blocks-per-grid 1 1)
         <span style="font-weight: bold;">:block-dim</span> (list block-size block-size 1))
        (cl-cuda:sync-memory-block c-out <span style="font-weight: bold;">:device-to-host</span>)))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">example-cuda-matrix-mul</span> ()
  (<span style="font-weight: bold;">let</span> ((size (expt 16 3)))
    (<span style="font-weight: bold;">let</span> ((mat1 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 10))
          (mat2 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 20)))
      (cuda-matrix-mul mat1 mat2))))
</pre>
</div>
<p>
that took some effort, i had to hard-code the block size because as it compiles to C the variable isnt defined as a constant which it has to be because i'd get this error if i were to replace the number 16 with the variable <code>block-size</code>:
</p>
<div class="org-src-container">
<pre class="src src-C">nvcc exits with <span style="font-weight: bold; text-decoration: underline;">code</span>: 1
/tmp/cl-cuda.EjtQeE.cu(60): error: expression must have a constant value
                        <span style="font-weight: bold;">__attribute__</span>((shared)) <span style="font-weight: bold; text-decoration: underline;">float</span> <span style="font-weight: bold; font-style: italic;">arr1_sub</span>[block_size][block_size];
</pre>
</div>
<p>
kernels are very limtied in terms of functionality, not everything can be used in kernels, almost everything is translated to C
now a small benchmark to test this against my previous cpu solution:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">example-cuda-matrix-mul</span> ()
  (<span style="font-weight: bold;">let</span> ((size (expt 16 3)))
    (<span style="font-weight: bold;">let</span> ((mat1 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 10))
          (mat2 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 20)))
      (cuda-matrix-mul mat1 mat2))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">example-cpu-matrix-mul</span> ()
  (<span style="font-weight: bold;">let</span> ((size 768))
    (<span style="font-weight: bold;">let</span> ((mat1 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 10))
          (mat2 (make-array (list size size) <span style="font-weight: bold;">:initial-element</span> 20)))
      (matrix-mul mat1 mat2))))

(time (example-cuda-matrix-mul))
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">Evaluation took:</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">2.776 seconds of real time</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">2.771769 seconds of total run time (2.600099 user, 0.171670 system)</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">[ Run times consist of 0.032 seconds GC time, and 2.740 seconds non-GC time. ]</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">99.86% CPU</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">7,192,807,350 processor cycles</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">268,435,488 bytes consed</span>

(time (example-cpu-matrix-mul))
<span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">Evaluation took:</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">6.533 seconds of real time</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">6.530840 seconds of total run time (6.530840 user, 0.000000 system)</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">99.97% CPU</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">16,934,213,216 processor cycles</span>
<span style="font-weight: bold; font-style: italic;">;;   </span><span style="font-weight: bold; font-style: italic;">14,155,824 bytes consed</span>
</pre>
</div>
<p>
the values dont even scale linearly, the gpu version is much faster, a benchmark figure here would be a good idea but im too lazy to bother with that atm</p>
</div>
</div>
</div>
</div>
</body>
</html>
