<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="mahmood sheikh" />
<meta name="description" content="using the symbolic capabilities of lisp to write inference engines and more" />
<meta name="generator" content="Org Mode" />
<title>symbolic logic in common lisp</title><!-- lambda icon, frail attempt -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%22100%22 color=%22red%22>Î»</text></svg>">
<!-- not-so-awesome awesome font -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

<link rel="stylesheet" href="/main.css">
</head>
<body>
<div id="preamble" class="status">
<div class="navbar">
  <a href='/'>home</a>
  <a href='/blog.html'>blog</a>
  <a href='/archive.html'>archive</a>
  <a href='/about.html'>about</a>
</div>
</div>
<div id="content" class="content">
<p>
logic programming in common lisp
</p>
<div id="outline-container-org5c68374" class="outline-2">
<h2 id="org5c68374">logical statements</h2>
<div class="outline-text-2" id="text-org5c68374">
<p>
we make use of the symbolic capabilities of lisp, we use quoting and symbols to represent logical statements, e.g. given the following knowledge base of horn clauses:
</p>

<div class="equation-container">
<span class="equation">
<img src="ltx/724d7a0e501.svg" alt="\begin{align*}
  &amp;amp;P \implies Q\\
  &amp;amp;L \land M \implies P\\
  &amp;amp;B \land L \implies M\\
  &amp;amp;A \land P \implies L\\
  &amp;amp;A \land B \land S \implies L\\
  &amp;amp;A\\
  &amp;amp;B
\end{align*}
" style="height: 10.4472em; vertical-align: -0.4020em; display: inline-block" class="org-latex org-latex-inline" />
</span>
</div>
<p>
in lisp we could write it as:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*kb*</span>
  '((implies p q)
    (implies (and l m) p)
    (implies (and b l) m)
    (implies (and a p) l)
    (implies (and a b s) l)
    A
    B))
*kb*
</pre>
</div>

<pre class="example">
((IMPLIES P Q) (IMPLIES (AND L M) P) (IMPLIES (AND B L) M)
 (IMPLIES (AND A P) L) (IMPLIES (AND A B S) L) A B)
</pre>


<p>
the choice of the symbols <code>implies, and</code> could vary, but essentially we should write code that deals properly with these symbols based on their names. other symbols we may use are <code>or, iff</code>.
</p>

<p>
so a knowledge base is just a (nested) list of propositions.
</p>

<p>
what about predicates? e.g. statements like <img src="ltx/526e0a9cc4e.svg" alt="\(Human(John)\)" style="height: 0.9843em; vertical-align: -0.2418em; display: inline-block" class="org-latex org-latex-inline" />?, that should be simple enough, we just use <code>'(Human John)</code>, so instead of <b>infix notation</b>, we use lisp's infamous <b>prefix notation</b>, we dont need to worry about <code>(Human John)</code> sharing the same form as <code>(and x1 x2)</code>, as <code>and</code> can be considered just a boolean function like <code>Human</code>, after all. any expression that is in the form <code>(whatever x1 x2 ... xn)</code> would imply that <code>whatever</code> is meant to be treated as a boolean function.
</p>

<p>
first obstacle we may face is the issue of distinguishing a variable from a constant symbol, how can we tell whether a symbol represents a variable or a constant (an immutable object)? after all both are just symbols (in our implementation), for example consider <code>person</code> vs <code>John</code>, inherently, <code>person</code> is a variable that applies to everyone and <code>John</code> is a constant that only describes one person (in a simplified context where John refers to a friend, for example). a simple solution to this problem would be to use special syntax for variables, like <code>?x</code>, here, <code>?x</code> would mean we're dealing with a variable, and a symbol without a question mark prefix, for example <code>x</code>, is recognized as a constant.
</p>

<p>
in our previous example, this doesnt make much difference as we were dealing with constants only, consider this example which demonstrates how we apply the idea of prefixing variables with a question mark:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*kb*</span>
  '((person john) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">person(john)</span>
    (implies (person ?x) (human ?x)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">person(x) =&gt; human(x)</span>
    (implies (and (not (widower ?x)) (father ?x)) (married ?x))))
*kb*
</pre>
</div>

<pre class="example">
((PERSON JOHN) (IMPLIES (PERSON ?X) (HUMAN ?X))
 (IMPLIES (AND (NOT (WIDOWER ?X)) (FATHER ?X)) (MARRIED ?X)))
</pre>


<p>
how about substitutions? how do we represent for example the substitution <img src="ltx/295812a0b94.svg" alt="\(\{x/val,y/val2\}\)" style="height: 0.9951em; vertical-align: -0.2525em; display: inline-block" class="org-latex org-latex-inline" />, we just use an association list:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">let</span> ((sub nil)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">sub is the substitution</span>
  (push (cons '?x 'val1) sub) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">add pair using push</span>
  (push (cons '?y 'val2) sub)
  sub)
</pre>
</div>

<pre class="example">
((?Y . VAL2) (?X . VAL1))
</pre>
</div>
</div>
<div id="outline-container-orgcdce261" class="outline-2">
<h2 id="orgcdce261">early inference engines</h2>
<div class="outline-text-2" id="text-orgcdce261">
<p>
imma start off with the unification algorithm, this one differs a bit from the pseudocode version, as it doesnt apply the <b>occur check</b> and doesnt distinguish between a compound statement or a list of expressions, as they are only used to represent predicates
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">variable?</span> (x)
  <span style="font-style: italic;">"return whether an expression is a variable"</span>
  (<span style="font-weight: bold;">if</span> (atom x)
      (equal (char (symbol-name x) 0) #\?) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">if symbol starts with a question mark</span>
      nil))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">compound?</span> (obj)
  <span style="font-style: italic;">"whether an object is compound, or simply whether its a cons cell or not '(atom obj)' returns false for a cons cell"</span>
  (not (atom obj)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unify</span> (x y <span style="font-weight: bold; text-decoration: underline;">&amp;optional</span> (sub nil))
  <span style="font-style: italic;">"x,y are logical statements, sub is the substitution, sub is initalized to `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">nil</span><span style="font-style: italic;">', if it ever becomes `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">failure</span><span style="font-style: italic;">', it means we've failed to find a substitution, we return `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">failure</span><span style="font-style: italic;">' (symbol), otherwise we return a substitution (could be `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">nil</span><span style="font-style: italic;">' which denotes an empty substitution)"</span>
  (<span style="font-weight: bold;">if</span> (equal sub 'failure)
      'failure
      (<span style="font-weight: bold;">if</span> (equal x y)
          sub
          (<span style="font-weight: bold;">if</span> (variable? x)
              (unify-var x y sub)
              (<span style="font-weight: bold;">if</span> (variable? y)
                  (unify-var y x sub)
                  (<span style="font-weight: bold;">if</span> (and (compound? x) (compound? y))
                      (unify (rest x) (rest y) (unify (first x) (first y) sub))
                      'failure)))))) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">failure</span>

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unify-var</span> (var x <span style="font-weight: bold; text-decoration: underline;">&amp;optional</span> (sub t))
  <span style="font-style: italic;">"returns a substitution"</span>
  (<span style="font-weight: bold;">let*</span> ((sub-entry (assoc var sub)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">an entry in the substitution that corresponds to var, if no such entry exists, both sub-entry and val will be nil</span>
         (val (cdr sub-entry)))
    (<span style="font-weight: bold;">if</span> sub-entry
        (unify val x sub)
        (<span style="font-weight: bold;">if</span> (assoc x sub)
            (unify var val sub)
            <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">(if (occur-check? var x) ;; occur check, not implemented</span>
            <span style="font-weight: bold; font-style: italic;">;;     </span><span style="font-weight: bold; font-style: italic;">'failure</span>
            <span style="font-weight: bold; font-style: italic;">;;     </span><span style="font-weight: bold; font-style: italic;">(push (cons var x) sub))))))</span>
            (push (cons var x) sub)))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unify-success?</span> (unify-out)
  <span style="font-style: italic;">"check whether the value returned by `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">unify</span><span style="font-style: italic;">' represents a proper substitution and not a failure"</span>
  <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">(listp unify-out) ;; alternative solution</span>
  (not (eq unify-out 'failure)))
</pre>
</div>
<p>
a test:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(unify '(person john) '(person ?x))
</pre>
</div>

<pre class="example">
((?X . JOHN))
</pre>


<p>
next up, we need to implement forward chaining and backward chaining which take in a knowledge base of statements which are definite clauses and do algorithmic inference, this code makes use of <a href="/common_lisp_math_utils.html#20230503T204107">common lisp math utils</a>
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">find-variables-in-statement</span> (statement)
  <span style="font-style: italic;">"find the variables in the list `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">statement</span><span style="font-style: italic;">' (variables are symbols that start with '?')"</span>
  (<span style="font-weight: bold;">let</span> ((vars))
    (<span style="font-weight: bold;">loop</span> for myelt in statement do
      (<span style="font-weight: bold;">if</span> (variable? myelt)
          (setf vars (union (list myelt) vars))
          (<span style="font-weight: bold;">when</span> (not (atom myelt))
            (setf vars (union (find-variables-in-statement myelt) vars)))))
    vars))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">find-constants-in-statement</span> (statement)
  <span style="font-style: italic;">"find all constants in a statement, constants are non-variable literals, basically words that arent predicates (symbol at the beginning of a list) or variables (symbol starting with '?')"</span>
  (<span style="font-weight: bold;">if</span> (atom statement)
      (<span style="font-weight: bold;">if</span> (variable? statement)
          nil
          (list statement))
      (<span style="font-weight: bold;">let</span> ((constants))
        (<span style="font-weight: bold;">loop</span> for myelt in (cdr statement) do
          (<span style="font-weight: bold;">if</span> (compound? myelt)
              (setf constants (union (find-constants-in-statement (cdr myelt)) constants))
              (setf constants (union (find-constants-in-statement myelt) constants))))
        constants)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">find-constants-in-knowledge-base</span> (knowledge-base)
  <span style="font-style: italic;">"find all constants in a knowledge base"</span>
  (<span style="font-weight: bold;">let</span> ((constants))
    (<span style="font-weight: bold;">loop</span> for statement in knowledge-base do
      (setf constants (union (find-constants-in-statement statement) constants)))
    constants))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">standardize-variables</span> (formula)
  <span style="font-style: italic;">"replace variables with new unseen unique variable names, implementation is inefficient but it'll do for now</span>
<span style="font-style: italic;">example usage:</span>
<span style="font-style: italic;">CL-USER&gt; (setf a '(hi ?there (whats up) up ?there ?what))</span>
<span style="font-style: italic;">CL-USER&gt; (standardize-variables a)</span>
<span style="font-style: italic;">(HI #:?479 (WHATS UP) UP #:?479 #:?481)</span>
<span style="font-style: italic;">CL-USER&gt; (standardize-variables '(implies (and (king ?x) (greedy ?x)) (evil ?x)))</span>
<span style="font-style: italic;">(IMPLIES (AND (KING #:?495) (GREEDY #:?495)) (EVIL #:?495))</span>
<span style="font-style: italic;">"</span>
  (<span style="font-weight: bold;">let</span> ((vars (<span style="font-weight: bold;">if</span> (compound? formula)
                  (find-variables-in-statement formula)
                  nil))) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">nil if the formula is just a constant</span>
    (<span style="font-weight: bold;">loop</span> for var in vars do
      <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">generate a new variable (symbol) that starts with '?' to replace each variable</span>
      (setf formula (subst (gensym <span style="font-style: italic;">"?"</span>) var formula)))
    formula))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">all-substitutions</span> (variables constants)
  <span style="font-style: italic;">"generate all possible substitutions, a substitution is a list of cons's"</span>
  (list* nil <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">nil is a possible substitution too</span>
         (concatenate*
          (<span style="font-weight: bold;">let</span> ((variable-combinations (combinations-upto-length variables)))
            (<span style="font-weight: bold;">loop</span> for variable-combination in variable-combinations
                  collect (<span style="font-weight: bold;">let</span> ((constant-variations (variations-with-repetition constants (length variable-combination))))
                            (<span style="font-weight: bold;">loop</span> for constant-variation in constant-variations
                                  collect (pairlis variable-combination constant-variation))))))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">apply-substitution</span> (sub formula)
  <span style="font-style: italic;">"given the substitution `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">sub</span><span style="font-style: italic;">', which is a list of conses (basically an alist), apply it to a given formula"</span>
  (<span style="font-weight: bold;">loop</span> for entry in sub do
    (setf formula (subst (cdr entry) (car entry) formula)))
  formula)

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">implication?</span> (formula)
  <span style="font-style: italic;">"check whether a logic formula is an implication formula of the form 'something =&gt; something' or in lisp (implies something something)"</span>
  (<span style="font-weight: bold;">when</span> (compound? formula)
    (eq (first formula) 'implies)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">parse-implication</span> (formula)
  <span style="font-style: italic;">"given an implication formula `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">formula</span><span style="font-style: italic;">', return both the implying expression and the implied expression (precedent and consequent)"</span>
  (<span style="font-weight: bold;">if</span> (implication? formula)
      (values (second formula) (third formula))
      (values nil formula)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">conjunction?</span> (formula)
  <span style="font-style: italic;">"check if a formula is a conjunction of predicates"</span>
  (<span style="font-weight: bold;">when</span> (compound? formula)
    (eq (first formula) 'and)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining</span> (knowledge-base query <span style="font-weight: bold; text-decoration: underline;">&amp;optional</span> (add-query-to-kb t))
  <span style="font-style: italic;">"apply the forward chaining algorithm to the knowledge base `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">knowledge-base</span><span style="font-style: italic;">' and the query `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">query</span><span style="font-style: italic;">', tries to infer the query from the knowledge base, returns `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">nil</span><span style="font-style: italic;">' if it fails, if `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">add-query-to-kb</span><span style="font-style: italic;">' is `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">t</span><span style="font-style: italic;">', `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">query</span><span style="font-style: italic;">' gets added to the knowledge base (along with the other conclusions)"</span>
  (<span style="font-weight: bold;">let</span> ((inference-alist-list)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">list of association lists that holds the antecedents of the inferences, each association list corresponds to a chaining step</span>
    (<span style="font-weight: bold;">loop</span> do
      (<span style="font-weight: bold;">let</span> ((new) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">list to hold newly inferred sentences on each iteration</span>
            (inference-alist))
        (<span style="font-weight: bold;">loop</span> for formula in knowledge-base do
          (<span style="font-weight: bold;">when</span> (implication? formula)
            <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">in an implication 'a-&gt;b', 'a' is the antecedent and 'b' is the consequent</span>
            (<span style="font-weight: bold;">multiple-value-bind</span> (antecedent consequent)
                (parse-implication formula)
              (<span style="font-weight: bold;">let*</span> ((standardized-antecedent (standardize-variables antecedent)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">change variable names in formula to avoid unification problems, see [[id:40d1a33f-7e80-4b94-bc0c-c778beefca01::note:note1]]</span>
                     (vars (append (find-variables-in-statement formula)
                                   (find-variables-in-statement standardized-antecedent))))
                <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">generate possible values for the substitution, see [[id:bd481a5c-e869-440e-be1d-33e0838620f9::note:theta_domain]]</span>
                (<span style="font-weight: bold;">loop</span> for sub in (all-substitutions vars (find-constants-in-knowledge-base knowledge-base)) do
                  (<span style="font-weight: bold;">loop</span> for some-premises in (variations-upto-length
                                              (remove-if #'implication?
                                                         knowledge-base))
                        do (<span style="font-weight: bold;">when</span> (or (equal (apply-substitution sub antecedent)
                                            (apply-substitution sub (list* 'and some-premises))) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">construct the AND (conjunction) predicate</span>
                                     (equal (apply-substitution sub (list antecedent))
                                            (apply-substitution sub some-premises)))
                             (<span style="font-weight: bold;">let</span> ((actual-consequent (apply-substitution sub consequent)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">non-standardized (original variables names) consequent</span>
                                   (unifies nil))
                               <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">check if it unifies with another formula something in `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">new</span><span style="font-weight: bold; font-style: italic;">'</span>
                               (<span style="font-weight: bold;">loop</span> for other-formula in new do
                                 (setf unifies (or unifies
                                                   (unify-success? (unify actual-consequent other-formula)))))
                               <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">check if it unifies with another formula something in `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">knowledge-base</span><span style="font-weight: bold; font-style: italic;">'</span>
                               (<span style="font-weight: bold;">loop</span> for other-formula-again in knowledge-base do
                                 (setf unifies (or unifies
                                                   (unify-success? (unify actual-consequent other-formula-again)))))
                               (<span style="font-weight: bold;">when</span> (not unifies)
                                 (setf new (append new (list actual-consequent)))
                                 (setf inference-alist
                                       (append inference-alist
                                               (list (cons actual-consequent
                                                           (apply-substitution sub antecedent)))))
                                 (<span style="font-weight: bold;">let</span> ((unify-out (unify actual-consequent query)))
                                   (<span style="font-weight: bold;">when</span> (unify-success? unify-out)
                                     (<span style="font-weight: bold;">when</span> add-query-to-kb
                                       (nconc knowledge-base new)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">final addition to knowledge base before returning</span>
                                     (setf inference-alist-list (append inference-alist-list (list inference-alist)))
                                     (<span style="font-weight: bold;">return-from</span> forward-chaining
                                       (values unify-out
                                               inference-alist-list)))))))))))))
        (setf inference-alist-list (append inference-alist-list (list inference-alist)))
        (<span style="font-weight: bold;">if</span> new
            (nconc knowledge-base new)
            (<span style="font-weight: bold;">return-from</span> forward-chaining (values nil inference-alist-list)))))))
</pre>
</div>
<p>
example usage:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining-test-1</span> ()
  (setf *forward-chaining-test-1-kb*
        '((implies (and (american ?x) (weapon ?y) (sells ?x ?y ?z) (hostile ?z)) (criminal ?x))
          (implies (and (missile ?x) (owns nono ?x)) (sells west ?x nono))
          (implies (missile ?x) (weapon ?x))
          (implies (enemy ?x america) (hostile ?x))
          (owns nono m1)
          (missile m1)
          (american west)
          (enemy nono america)))
  (<span style="font-weight: bold;">let</span> ((kb2 (copy-tree *forward-chaining-test-1-kb*)))
    (<span style="font-weight: bold;">multiple-value-bind</span> (substitution inference-alist-list)
        (forward-chaining kb2 '(criminal west))
      <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">not a good idea to use setf but should be fine for debugging</span>
      (setf *forward-chaining-test-1-inference-alist-list* inference-alist-list)
      (setf *forward-chaining-test-1-kb-result* kb2)
      kb2)))
</pre>
</div>
<p>
some functions (that do their best) to "unpack" a knowledge base by unpacking conjunctions and implications into multiple smaller statements that are easier to deal with (there isnt much we can do when the precedent of an implication is a logical connective)
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unpack-implication</span> (implication)
  (<span style="font-weight: bold;">multiple-value-bind</span> (antecedent consequent)
      (parse-implication implication)
    (<span style="font-weight: bold;">if</span> (conjunction? consequent)
        (mapcar (<span style="font-weight: bold;">lambda</span> (consequent-predicate) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">one predicate from the conjunction in the consequent</span>
                  (list 'implies antecedent consequent-predicate))
                (unpack-conjunction consequent))
        (list implication))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unpack-conjunction</span> (conjunction)
  (cdr conjunction))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unpack-formula</span> (formula)
  (<span style="font-weight: bold;">if</span> (implication? formula)
      (unpack-implication formula)
      (<span style="font-weight: bold;">if</span> (conjunction? formula)
          (unpack-conjunction formula)
          (list formula))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unpack-knowledge-base</span> (kb)
  (<span style="font-weight: bold;">let</span> ((new-kb))
    (<span style="font-weight: bold;">loop</span> for formula in kb do
      (setf new-kb (append new-kb (unpack-formula formula))))
    new-kb))
</pre>
</div>
<p>
a function to generate a graph from a knowledge base, see <a href="/working_with_graphs_in_common_lisp.html#20230813T012934">common lisp graphs</a>:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">generate-graph-from-knowledge-base</span> (kb)
  <span style="font-style: italic;">"generate and-or graph (not really, cant tell OR from AND) for a knowledge base"</span>
  (<span style="font-weight: bold;">let</span> ((g (make-graph)))
    (<span style="font-weight: bold;">loop</span> for statement in (unpack-knowledge-base kb) do
      (<span style="font-weight: bold;">if</span> (implication? statement)
          (<span style="font-weight: bold;">multiple-value-bind</span> (antecedent consequent) (parse-implication statement)
            (<span style="font-weight: bold;">if</span> (conjunction? antecedent)
                (<span style="font-weight: bold;">loop</span> for predicate in (cdr antecedent) do
                  (graph-add-edge g predicate consequent))
                (graph-add-edge g antecedent consequent)))
          (<span style="font-weight: bold;">if</span> (conjunction? statement)
              (<span style="font-weight: bold;">loop</span> for predicate in (cdr statement) do
                (graph-add-vertex g predicate))
              (graph-add-vertex g statement))))
    g))
</pre>
</div>
<p>
example usage:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining-test-2</span> ()
  (<span style="font-weight: bold;">let</span> ((kb (copy-tree '((implies (and (american ?x) (weapon ?y) (sells ?x ?y ?z) (hostile ?z)) (criminal ?x))
                         (implies (and (missile ?x) (owns nono ?x)) (sells west ?x nono))
                         (implies (missile ?x) (weapon ?x))
                         (implies (enemy ?x america) (hostile ?x))
                         (owns nono m1)
                         (missile m1)
                         (american west)
                         (enemy nono america)))))
    (<span style="font-weight: bold;">let</span> ((g (generate-graph-from-knowledge-base kb))
          (vertex-idx 0) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">to number vertices (gotta do it for proper drawing of the graph), each vertex gets a unique number</span>
          (vertex-indicies-cache nil)) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">cache vertex indicies</span>
      (graph-generate-tikz
       g
       <span style="font-weight: bold;">:format-function</span> (<span style="font-weight: bold;">lambda</span> (vertex)
                          (<span style="font-weight: bold;">let</span> ((vertex-entry
                                  (assoc
                                   vertex
                                   vertex-indicies-cache
                                   <span style="font-weight: bold;">:test</span> #'equal)))
                                   <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">:test (lambda (predicate1 predicate2)</span>
                                   <span style="font-weight: bold; font-style: italic;">;;         </span><span style="font-weight: bold; font-style: italic;">(unify-success? (unify predicate1 predicate2))))))</span>
                            (<span style="font-weight: bold;">if</span> vertex-entry
                                (format nil <span style="font-style: italic;">"v~A/{~A}"</span> (cdr vertex-entry) vertex)
                                (<span style="font-weight: bold;">progn</span>
                                  (incf vertex-idx)
                                  (setf vertex-indicies-cache (acons vertex vertex-idx vertex-indicies-cache))
                                  (format nil <span style="font-style: italic;">"v~A/{~A}"</span> vertex-idx vertex)))))
       <span style="font-weight: bold;">:tikz-params</span> <span style="font-style: italic;">"layered layout, grow=up, edges={-{Stealth[]}}, edges=rounded corners"</span>
       <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">:node-distance 50</span>
       <span style="font-weight: bold;">:directed</span> t))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">(forward-chaining-test-2)
</pre>
</div>


<div class="equation-container">
<span class="equation">
<img src="ltx/530b299128f.svg" alt="\begin{tikzpicture}
\graph[layered layout, grow=up, edges={-{Stealth[]}}, edges=rounded corners] {
v1/{(ENEMY NONO AMERICA)},
v2/{(AMERICAN WEST)},
v3/{(MISSILE M1)},
v4/{(OWNS NONO M1)},
v5/{(ENEMY ?X AMERICA)} -&amp;gt; v6/{(HOSTILE ?X)},
v7/{(MISSILE ?X)} -&amp;gt; v8/{(WEAPON ?X)},
v9/{(OWNS NONO ?X)} -&amp;gt; v10/{(SELLS WEST ?X NONO)},
v7/{(MISSILE ?X)} -&amp;gt; v10/{(SELLS WEST ?X NONO)},
v11/{(HOSTILE ?Z)} -&amp;gt; v12/{(CRIMINAL ?X)},
v13/{(SELLS ?X ?Y ?Z)} -&amp;gt; v12/{(CRIMINAL ?X)},
v14/{(WEAPON ?Y)} -&amp;gt; v12/{(CRIMINAL ?X)},
v15/{(AMERICAN ?X)} -&amp;gt; v12/{(CRIMINAL ?X)},
};\end{tikzpicture}
" style="height: 4.3759em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />
</span>
</div>

<p>
functions to generate a graph from the forward chaining process (see <a href="/working_with_graphs_in_common_lisp.html#20230813T012934">common lisp graphs</a>):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining-generate-inference-graph</span> (inference-alist-list)
  <span style="font-style: italic;">"generate and-or graph (not really, cant tell OR from AND) for a knowledge base"</span>
  (<span style="font-weight: bold;">let</span> ((g (make-graph)))
    (<span style="font-weight: bold;">loop</span> for inference-alist in inference-alist-list do
      (<span style="font-weight: bold;">loop</span> for entry in inference-alist do
        (<span style="font-weight: bold;">let</span> ((precedent (cdr entry))
              (consequent (car entry)))
          (<span style="font-weight: bold;">if</span> (conjunction? precedent)
              (<span style="font-weight: bold;">loop</span> for predicate in (cdr precedent) do
                (<span style="font-weight: bold;">if</span> (conjunction? consequent)
                    (<span style="font-weight: bold;">loop</span> for consequent-predicate in (cdr consequent) do
                      (graph-add-edge g predicate consequent-predicate))
                    (graph-add-edge g predicate consequent)))
              (<span style="font-weight: bold;">if</span> (conjunction? consequent)
                  (<span style="font-weight: bold;">loop</span> for consequent-predicate in (cdr consequent) do
                    (graph-add-edge g precedent consequent-predicate))
                  (graph-add-edge g precedent consequent))))))
    g))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining-generate-tikz-graph</span> (inference-alist-list)
  (<span style="font-weight: bold;">let*</span> ((g (forward-chaining-generate-inference-graph inference-alist-list))
         (vertex-idx 0) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">to number vertices (gotta do it for proper drawing of the graph), each vertex gets a unique number)</span>
         (vertex-indicies-cache nil) <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">cache vertex indicies</span>
         (vertex-format-function
           (<span style="font-weight: bold;">lambda</span> (vertex)
             (<span style="font-weight: bold;">let</span> ((vertex-entry
                     (assoc
                      vertex
                      vertex-indicies-cache
                      <span style="font-weight: bold;">:test</span> #'equal)))
               (<span style="font-weight: bold;">if</span> vertex-entry
                   (format nil <span style="font-style: italic;">"v~A/{~A}"</span> (cdr vertex-entry) vertex)
                   (<span style="font-weight: bold;">progn</span>
                     (incf vertex-idx)
                     (setf vertex-indicies-cache (acons vertex vertex-idx vertex-indicies-cache))
                     (format nil <span style="font-style: italic;">"v~A/{~A}"</span> vertex-idx vertex)))))))
    (graph-generate-tikz
     g
     <span style="font-weight: bold;">:format-function</span> vertex-format-function
     <span style="font-weight: bold;">:tikz-params</span> <span style="font-style: italic;">"layered layout, grow=up, edges={-{Stealth[]}}, edges=rounded corners, level sep=40px"</span>
     <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">incomplete attempt to make the figure look more like [[id:bd481a5c-e869-440e-be1d-33e0838620f9::fig:fig4][forward chaining]]</span>
     <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">:tikz-postamble</span>
     <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">(concatenate*</span>
     <span style="font-weight: bold; font-style: italic;">;;  </span><span style="font-weight: bold; font-style: italic;">(mapcar (lambda (inference-alist)</span>
     <span style="font-weight: bold; font-style: italic;">;;            </span><span style="font-weight: bold; font-style: italic;">(apply #'concatenate</span>
     <span style="font-weight: bold; font-style: italic;">;;                   </span><span style="font-weight: bold; font-style: italic;">(append (list 'string)</span>
     <span style="font-weight: bold; font-style: italic;">;;                           </span><span style="font-weight: bold; font-style: italic;">(list "{[same layer] ")</span>
     <span style="font-weight: bold; font-style: italic;">;;                           </span><span style="font-weight: bold; font-style: italic;">(mapcar (lambda (vertex-entry)</span>
     <span style="font-weight: bold; font-style: italic;">;;                                     </span><span style="font-weight: bold; font-style: italic;">(format nil "~A," (funcall vertex-format-function</span>
     <span style="font-weight: bold; font-style: italic;">;;                                                                </span><span style="font-weight: bold; font-style: italic;">(car vertex-entry))))</span>
     <span style="font-weight: bold; font-style: italic;">;;                                   </span><span style="font-weight: bold; font-style: italic;">inference-alist)</span>
     <span style="font-weight: bold; font-style: italic;">;;                           </span><span style="font-weight: bold; font-style: italic;">(list " };"))))</span>
     <span style="font-weight: bold; font-style: italic;">;;          </span><span style="font-weight: bold; font-style: italic;">*forward-chaining-test-1-inference-alist-list*))</span>
     <span style="font-weight: bold;">:directed</span> t)))
</pre>
</div>
<p>
example usage:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">forward-chaining-test-3</span> ()
  (<span style="font-weight: bold;">let</span> ((kb (copy-tree
             '((implies (and (american ?x) (weapon ?y) (sells ?x ?y ?z) (hostile ?z)) (criminal ?x))
               (implies (and (missile ?x) (owns nono ?x)) (sells west ?x nono))
               (implies (missile ?x) (weapon ?x))
               (implies (enemy ?x america) (hostile ?x))
               (owns nono m1)
               (missile m1)
               (american west)
               (enemy nono america)))))
    (<span style="font-weight: bold;">multiple-value-bind</span> (substitution inference-alist-list)
        (forward-chaining kb '(criminal west))
      <span style="font-weight: bold; font-style: italic;">;; </span><span style="font-weight: bold; font-style: italic;">not a good idea to use setf but should be fine for debugging</span>
      (forward-chaining-generate-tikz-graph inference-alist-list))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">(forward-chaining-test-3)
</pre>
</div>


<div class="equation-container">
<span class="equation">
<img src="ltx/8f2490887ae.svg" alt="\begin{tikzpicture}
\graph[layered layout, grow=up, edges={-{Stealth[]}}, edges=rounded corners, level sep=40px] {
v1/{(HOSTILE NONO)} -&amp;gt; v2/{(CRIMINAL WEST)},
v3/{(SELLS WEST M1 NONO)} -&amp;gt; v2/{(CRIMINAL WEST)},
v4/{(WEAPON M1)} -&amp;gt; v2/{(CRIMINAL WEST)},
v5/{(AMERICAN WEST)} -&amp;gt; v2/{(CRIMINAL WEST)},
v6/{(ENEMY NONO AMERICA)} -&amp;gt; v1/{(HOSTILE NONO)},
v7/{(MISSILE M1)} -&amp;gt; v4/{(WEAPON M1)},
v8/{(OWNS NONO M1)} -&amp;gt; v3/{(SELLS WEST M1 NONO)},
v7/{(MISSILE M1)} -&amp;gt; v3/{(SELLS WEST M1 NONO)},
};\end{tikzpicture}
" style="height: 12.5137em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />
</span>
</div>

<p>
the backward chaining algorithm (we dont implement it as a generator here):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">backward-chaining</span> (knowledge-base query)
  <span style="font-style: italic;">"apply backward chaining, find all proofs for `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">query</span><span style="font-style: italic;">'"</span>
  (backward-chaining-or knowledge-base query nil))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">backward-chaining-or</span> (knowledge-base goal substitution)
  <span style="font-style: italic;">"returns substitutions that prove `</span><span style="font-weight: bold; font-style: italic; text-decoration: underline;">goal</span><span style="font-style: italic;">'"</span>
  (format t <span style="font-style: italic;">"~A &lt;- "</span> goal)
  (concatenate*
   (<span style="font-weight: bold;">loop</span> for implication-formula in knowledge-base
         collect (<span style="font-weight: bold;">multiple-value-bind</span> (precedent consequent)
                     (parse-implication (standardize-variables implication-formula))

                   (<span style="font-weight: bold;">loop</span> for substitution1 in (backward-chaining-and
                                               knowledge-base
                                               (<span style="font-weight: bold;">if</span> (conjunction? precedent)
                                                   (cdr precedent)
                                                   precedent)
                                               (unify consequent
                                                      goal
                                                      substitution))
                         collect substitution1)))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">backward-chaining-and</span> (knowledge-base goals substitution)
  (<span style="font-weight: bold;">if</span> (equal 'failure substitution)
      nil
      (<span style="font-weight: bold;">if</span> (equal (length goals) 0)
          (list substitution)
          (concatenate*
           (<span style="font-weight: bold;">loop</span> for substitution1 in (backward-chaining-or knowledge-base
                                                            (apply-substitution substitution
                                                                                (first goals))
                                                            substitution)
                 collect (<span style="font-weight: bold;">loop</span> for substitution2 in (backward-chaining-and knowledge-base
                                                                           (rest goals)
                                                                           substitution1)
                               collect substitution2))))))
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
